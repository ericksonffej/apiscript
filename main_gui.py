import os
import sys
import subprocess
import qdarktheme
from PySide6.QtWidgets import QApplication, QMainWindow, QMessageBox
from PySide6.QtCore import QFile, QProcess, Signal, QObject, QByteArray
from apiscript_gui import Ui_MainWindow
from validate import check_hash, check_vt_url, is_hash, is_ip, is_url
from functools import partial
from datetime import datetime as dt
import re

# names of QT Widgets are autogenerated
# see reTranslateUi for widget names

# https://stackoverflow.com/questions/52085223/how-to-use-pyqt-to-start-one-process-after-another-finishes

COMMAND_PATH = os.getcwd() + '\\.apiscript\\Scripts\\' + 'python.exe'

class SequentialManager(QObject):
    finished = Signal()
    resultsChanged = Signal(QByteArray)

    def __init__(self, parent=None):
        super(SequentialManager, self).__init__(parent)
        self.process = QProcess(self)
        self.process.finished.connect(self.handle_finished)
        self.process.readyReadStandardOutput.connect(self.handle_output)
        self.process.readyReadStandardError.connect(self.handle_err)

    def start(self, commands):
        self._commands = iter(commands)
        self.fetch_next()

    def fetch_next(self):
        try:
            commands = next(self._commands)
        except StopIteration:
            return False
        else:
            self.process.setProgram(COMMAND_PATH)
            self.process.setArguments(commands.split(' '))
            self.process.start()
        return True

    def handle_output(self):
        data = self.process.readAllStandardOutput()
        self.resultsChanged.emit(data)

    def handle_err(self):
        data = self.process.readAllStandardError()
        self.resultsChanged.emit(data)

    def handle_finished(self):
        if not self.fetch_next():
            self.finished.emit()

class MainWindow(QMainWindow):
    def __init__(self):
        super(MainWindow, self).__init__()
        self.ui = Ui_MainWindow()
        self.ui.setupUi(self)
        self.ui.plainTextEdit_2.setReadOnly(True)
        self.manager = SequentialManager(self)
        self.connect_signals_slots()
    
    def connect_signals_slots(self):
        self.ui.menuAbout.triggered.connect(self.about)
        self.ui.pushButton.clicked.connect(self.investigate_iocs)
        self.ui.pushButton_2.clicked.connect(self.open_output_folder)
        self.manager.resultsChanged.connect(self.on_results_changed)
    
    def about(self):
        QMessageBox.about(self,
        "About OSINT APIScript",
        "<p> Made with Python </p>",
        )

    def open_output_folder(self):
        subprocess.run(['explorer', os.getcwd() + '\output'])
    
    def on_results_changed(self, result):
        self.ui.plainTextEdit_2.appendPlainText(str(result, 'utf-8'))
    
    def investigate_iocs(self):
        self.ui.plainTextEdit_2.setReadOnly(False)
        self.ui.pushButton.setEnabled(False)
        self.ui.plainTextEdit_2.clear()
        if self.ui.plainTextEdit.toPlainText() == "":
            ref_id = str(dt.now().isoformat('_'))
        else:
            ref_id = re.sub('[^A-Za-z0-9]+', '', self.ui.plainTextEdit.toPlainText()) 
        if self.ui.plainTextEdit.toPlainText() == '':
            self.ui.plainTextEdit_2.appendPlainText('[-] ERROR: Please insert at least 1 IoC')
            self.ui.plainTextEdit_2.setReadOnly(True)
            self.ui.pushButton.setEnabled(True)
            return
        iocs = self.ui.plainTextEdit.toPlainText().split("\n")
        if len(iocs) > 4:
            self.ui.plainTextEdit_2.appendPlainText('[-] ERROR: More than 4 IoCs are not allowed')
            self.ui.plainTextEdit_2.setReadOnly(True)
            self.ui.pushButton.setEnabled(True)
            return
        iocs = [string for string in iocs if string != '']
        commands = []
        for ioc in iocs:
            if is_hash(ioc):
                prompt = f"main.py --ticket {ref_id} --hash {ioc}"
                commands.append(prompt)
            elif is_ip(ioc):
                prompt = f"main.py --ticket {ref_id} --ip-address {ioc}"
                commands.append(prompt)
            elif is_url(ioc):
                prompt = f"main.py --ticket {ref_id} --url {ioc}"
                commands.append(prompt)
            else:
                self.ui.plainTextEdit_2.appendPlainText(f'[-] ERROR: Skipping invalid IoC or empty line')
        func = partial(self.manager.start, commands)
        func()
        self.ui.plainTextEdit_2.setReadOnly(True)
        self.ui.pushButton.setEnabled(True)

if __name__ == "__main__":
    app = QApplication(sys.argv)
    app.setStyleSheet(qdarktheme.load_stylesheet())
    window = MainWindow()
    window.show()

    sys.exit(app.exec())