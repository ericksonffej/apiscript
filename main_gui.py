import os
import sys
import subprocess
import qdarktheme
from PySide6.QtWidgets import QApplication, QMainWindow, QMessageBox, QDialog
from PySide6.QtCore import QFile, QProcess, Signal, QObject, QByteArray
from apiscript_gui import Ui_MainWindow
from del_dialog import Ui_Dialog
from validate import check_hash, check_vt_url, is_hash, is_ip, is_url
from functools import partial
from datetime import datetime as dt
import re
import logging
from pathlib import Path
from dateutil.relativedelta import relativedelta as rd

# names of QT Widgets are autogenerated
# see reTranslateUi for widget names

# https://stackoverflow.com/questions/52085223/how-to-use-pyqt-to-start-one-process-after-another-finishes

TODAY = dt.now()
OUTPUT_PATH = os.getcwd() + '\output'
COMMAND_PATH = os.getcwd() + '\\.apiscript\\Scripts\\' + 'python.exe'
logging.basicConfig(filename=f'apiscript.log', filemode='w', format='%(asctime)s - %(message)s', level=logging.DEBUG)

class SequentialManager(QObject):
    finished = Signal()
    resultsChanged = Signal(QByteArray)

    def __init__(self, parent=None):
        super(SequentialManager, self).__init__(parent)
        self.process = QProcess(self)
        self.process.finished.connect(self.handle_finished)
        self.process.readyReadStandardOutput.connect(self.handle_output)
        self.process.readyReadStandardError.connect(self.handle_err)

    def start(self, commands):
        logging.debug('started manager')
        self._commands = iter(commands)
        self.fetch_next()

    def fetch_next(self):
        try:
            commands = next(self._commands)
        except StopIteration:
            return False
        else:
            self.process.setProgram(COMMAND_PATH)
            self.process.setArguments(commands.split(' '))
            self.process.start()
        return True

    def handle_output(self):
        data = self.process.readAllStandardOutput()
        self.resultsChanged.emit(data)

    def handle_err(self):
        data = self.process.readAllStandardError()
        self.resultsChanged.emit(data)

    def handle_finished(self):
        if not self.fetch_next():
            self.finished.emit()

class MainWindow(QMainWindow):
    def __init__(self):
        super(MainWindow, self).__init__()
        self.ui = Ui_MainWindow()
        self.ui.setupUi(self)
        self.ui.plainTextEdit_2.setReadOnly(True)
        self.manager = SequentialManager(self)
        self.connect_signals_slots()
    
    def connect_signals_slots(self):
        self.ui.menuAbout.triggered.connect(self.about)
        self.ui.pushButton.clicked.connect(self.investigate_iocs)
        self.ui.pushButton_2.clicked.connect(self.open_output_folder)
        self.ui.pushButton_3.clicked.connect(self.delete_output_files)
        self.manager.resultsChanged.connect(self.on_results_changed)
    
    def about(self):
        QMessageBox.about(self,
        "About OSINT APIScript",
        "<p> Made with Python </p>",
        )

    def open_output_folder(self):
        subprocess.run(['explorer', OUTPUT_PATH])

    def investigate_iocs(self):
        self.ui.plainTextEdit_2.setReadOnly(False)
        self.ui.pushButton.setEnabled(False)
        self.ui.plainTextEdit_2.clear()
        if self.ui.plainTextEdit_2.toPlainText() == "":
            ref_id = str(TODAY.isoformat('_'))
        else:
            ref_id = re.sub(r'[^A-Za-z0-9]+', r'', self.ui.textEdit.toPlainText())
        print(ref_id)
        if self.ui.plainTextEdit.toPlainText() == '':
            self.ui.plainTextEdit_2.appendPlainText('[-] ERROR: Please insert at least 1 IoC')
            self.ui.plainTextEdit_2.setReadOnly(True)
            self.ui.pushButton.setEnabled(True)
            return
        iocs = self.ui.plainTextEdit.toPlainText().split("\n")
        if len(iocs) > 4:
            self.ui.plainTextEdit_2.appendPlainText('[-] ERROR: More than 4 IoCs are not allowed')
            self.ui.plainTextEdit_2.setReadOnly(True)
            self.ui.pushButton.setEnabled(True)
            return
        iocs = [string for string in iocs if string != '']
        commands = []
        for ioc in iocs:
            if is_hash(ioc):
                prompt = f"main.py --ticket {ref_id} --hash {ioc}"
                commands.append(prompt)
            elif is_ip(ioc):
                prompt = f"main.py --ticket {ref_id} --ip-address {ioc}"
                commands.append(prompt)
            elif is_url(ioc):
                prompt = f"main.py --ticket {ref_id} --url {ioc}"
                commands.append(prompt)
            else:
                self.ui.plainTextEdit_2.appendPlainText(f'[-] ERROR: Skipping invalid IoC or empty line')
        func = partial(self.manager.start, commands)
        print(f'{commands}')
        func()
        self.ui.plainTextEdit_2.setReadOnly(True)
        self.ui.pushButton.setEnabled(True)
    
    def delete_output_files(self):
        def _delete_files() -> None:
            try:
                nums = int(ui.textEdit.toPlainText())
            except ValueError:
                QMessageBox.critical(dialog, 'Error', 'Date input empty')
                return
            critical_time = rd(days=1)
            if ui.radioButton.isChecked(): # day
                critical_time = TODAY - rd(days=nums)
            elif ui.radioButton_2.isChecked(): # week
                critical_time = TODAY - rd(weeks=nums)
            elif ui.radioButton_3.isChecked(): # month
                critical_time = TODAY - rd(months=nums)
            deleted = 0
            for file in Path(OUTPUT_PATH).glob("*"):
                if file.is_file():
                    file_date = dt.fromtimestamp(file.stat().st_ctime)
                    if file_date < critical_time:
                        logging.debug(f'{file.absolute} will be deleted')
                        # file.unlink()
                        deleted += 1
            QMessageBox.information(dialog, 'Success', f'{deleted} files deleted.'); dialog.accept()
        dialog = QDialog()
        ui = Ui_Dialog()
        ui.setupUi(dialog)
        ui.pushButton.clicked.connect(_delete_files)
        ui.pushButton_2.clicked.connect(dialog.reject)
        dialog.exec()
        
    def on_results_changed(self, result):
        self.ui.plainTextEdit_2.appendPlainText(str(result, 'utf-8'))
    

if __name__ == "__main__":
    app = QApplication(sys.argv)
    app.setStyleSheet(qdarktheme.load_stylesheet())
    window = MainWindow()
    window.show()

    sys.exit(app.exec())